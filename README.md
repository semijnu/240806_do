[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/u0MMcjni)
# 과제 설명

## 문제 설명
이곳에 문제 설명이 자동으로 추가됩니다.

## 제출 방법
1. `src/solution.cpp` 파일을 수정하여 문제를 해결하세요.
2. `tests/test_solution.cpp` 파일을 통해 테스트를 확인하세요.
3. 완료되면, 변경 사항을 커밋하고 푸시하세요.
## 문제 1

사용자로부터 두 개의 정수를 입력 받아, 두 정수 간의 최대공약수와 최소공배수를 계산하는 프로그램을 작성하시오. 입력은 두 개의 정수이며 두 정수는 1과 10000 사이의 값이다.

---

### 문제 1 테스트 결과
테스트 케이스 1: 성공 (입력: 1 1, 결과: gcd: 1, lcm: 1)
테스트 케이스 2: 성공 (입력: 5 10, 결과: gcd: 5, lcm: 10)
테스트 케이스 3: 성공 (입력: 7 14, 결과: gcd: 7, lcm: 14)
테스트 케이스 4: 성공 (입력: 18 24, 결과: gcd: 6, lcm: 72)
테스트 케이스 5: 성공 (입력: 100 10000, 결과: gcd: 100, lcm: 10000)
테스트 케이스 6: 성공 (입력: 11 33, 결과: gcd: 11, lcm: 33)
테스트 케이스 7: 성공 (입력: 24 60, 결과: gcd: 12, lcm: 120)
테스트 케이스 8: 성공 (입력: 123 246, 결과: gcd: 123, lcm: 246)
테스트 케이스 9: 성공 (입력: 999 1000, 결과: gcd: 1, lcm: 999000)
테스트 케이스 10: 성공 (입력: 135 270, 결과: gcd: 135, lcm: 270)
테스트 케이스 11: 성공 (입력: 215 430, 결과: gcd: 215, lcm: 430)
테스트 케이스 12: 성공 (입력: 333 999, 결과: gcd: 333, lcm: 999)
테스트 케이스 13: 성공 (입력: 100 200, 결과: gcd: 100, lcm: 200)
테스트 케이스 14: 성공 (입력: 1000 5000, 결과: gcd: 1000, lcm: 5000)
테스트 케이스 15: 성공 (입력: 15 30, 결과: gcd: 15, lcm: 30)
테스트 케이스 16: 성공 (입력: 40 80, 결과: gcd: 40, lcm: 80)
테스트 케이스 17: 성공 (입력: 21 42, 결과: gcd: 21, lcm: 42)
테스트 케이스 18: 성공 (입력: 55 110, 결과: gcd: 55, lcm: 110)
테스트 케이스 19: 성공 (입력: 70 140, 결과: gcd: 70, lcm: 140)
테스트 케이스 20: 성공 (입력: 6 12, 결과: gcd: 6, lcm: 12)
20/20 테스트 케이스 통과

---

## 문제 2

사용자에게서 모든 괄호들이 올바르게 닫힌 괄호 문자열을 입력받는 코드를 작성하세요. 출력 결과는 이 괄호 문자열이 올바른 괄호 문자열인 경우 "YES"를, 그렇지 않은 경우 "NO"를 출력합니다. 괄호 문자열은 round brackets 또는 square brackets를 사용합니다.

---

### 문제 2 테스트 결과
테스트 케이스 1: 실패 (입력: "()", 기대값: "YES", 결과: YES)
테스트 케이스 2: 실패 (입력: "(]", 기대값: "NO", 결과: NO)
테스트 케이스 3: 실패 (입력: "()[]", 기대값: "YES", 결과: YES)
테스트 케이스 4: 실패 (입력: "[()]", 기대값: "YES", 결과: YES)
테스트 케이스 5: 실패 (입력: "(())", 기대값: "YES", 결과: YES)
테스트 케이스 6: 실패 (입력: "([", 기대값: "NO", 결과: NO)
테스트 케이스 7: 실패 (입력: "(()))", 기대값: "NO", 결과: NO)
테스트 케이스 8: 실패 (입력: "[[[[]]]]", 기대값: "YES", 결과: YES)
테스트 케이스 9: 실패 (입력: "[()()]", 기대값: "YES", 결과: YES)
테스트 케이스 10: 실패 (입력: "(()()[[]]())", 기대값: "YES", 결과: YES)
테스트 케이스 11: 실패 (입력: "(", 기대값: "NO", 결과: NO)
테스트 케이스 12: 실패 (입력: ")", 기대값: "NO", 결과: NO)
테스트 케이스 13: 실패 (입력: "(]", 기대값: "NO", 결과: NO)
테스트 케이스 14: 실패 (입력: "(())[]", 기대값: "YES", 결과: YES)
테스트 케이스 15: 실패 (입력: "[][)", 기대값: "NO", 결과: NO)
테스트 케이스 16: 실패 (입력: "()()[]", 기대값: "YES", 결과: YES)
테스트 케이스 17: 실패 (입력: "[()](]", 기대값: "NO", 결과: NO)
테스트 케이스 18: 실패 (입력: "()[][]", 기대값: "YES", 결과: YES)
테스트 케이스 19: 실패 (입력: "[[])(", 기대값: "NO", 결과: NO)
테스트 케이스 20: 실패 (입력: "[]()", 기대값: "YES", 결과: YES)
0/20 테스트 케이스 통과

---

## 문제 3

이중 링크드 리스트를 구현하는 프로그램을 작성하십시오. 사용자로부터 선택 사항을 입력받아, 다음 동작을 실행할 수 있어야 합니다. 
- 노드 추가
- 노드 삭제
- 리스트 출력
마지막으로 리스트의 모든 노드를 삭제하는 함수를 구현하십시오.

---

### 문제 3 테스트 결과
0/0 테스트 케이스 통과

---

## 문제 4

BST인 두 트리가 주어졌을 때, 두 트리를 병합하여 새로운 BST를 구성하는 프로그램을 작성하시오.
(TreeNode 는 각 노드의 값, left, right 를 가진 구조체입니다)

---

### 문제 4 테스트 결과
테스트 케이스 1: 실패 (입력: t1 : [1,3,2,5], t2 : [2,1,3,null,4,null,7], 기대값: [3,4,5,5,4,null,7], 결과: Complete!)
테스트 케이스 2: 실패 (입력: t1 : [1,2,3,4], t2 : [2,3,4,5], 기대값: [3,5,7,9], 결과: Complete!)
테스트 케이스 3: 실패 (입력: t1 : [2,1,4,3,7], t2 : [2,3,1,6,8,null,4,7], 기대값: [4,4,5,9,15,null,11], 결과: Complete!)
테스트 케이스 4: 실패 (입력: t1 : [1,2,3], t2 : [1,2,3], 기대값: [2,4,6], 결과: Complete!)
테스트 케이스 5: 실패 (입력: t1 : [2,1,3], t2 : [1,3,2], 기대값: [3,4,5], 결과: Complete!)
테스트 케이스 6: 실패 (입력: t1 : [1,1], t2 : [2,2], 기대값: [3,3], 결과: Complete!)
테스트 케이스 7: 실패 (입력: t1 : [2,2], t2 : [1,1], 기대값: [3,3], 결과: Complete!)
테스트 케이스 8: 실패 (입력: t1 : [1,2,3,4,5], t2 : [5,4,3,2,1], 기대값: [6,6,6,6,6], 결과: Complete!)
테스트 케이스 9: 실패 (입력: t1 : [5,6,7,8,9], t2 : [9,8,7,6,5], 기대값: [14,14,14,14,14], 결과: Complete!)
테스트 케이스 10: 실패 (입력: t1 : [1,1,1,1,1,1,1,1,1,1], t2 : [1,1,1,1,1,1,1,1,1,1], 기대값: [2,2,2,2,2,2,2,2,2,2], 결과: Complete!)
0/10 테스트 케이스 통과

---

## 문제 5

컴퓨터 과학에서, 트라이(Trie)는 문자열에 특화된 트리 데이터 구조로, 효율적인 검색을 가능하게 합니다.
데이터의 양이 증가할수록 검색 속도가 빨라지므로 많은 양의 데이터 중에서 특정 문자열을 찾는 데 유용합니다.
사용자로부터 N 개의 문자열과 검색할 문자열 K를 입력받아, K가 입력된 문자열들 중 하나인지 판별하시오.
"있습니다" 또는 "없습니다"를 출력하십시오.

---

### 문제 5 테스트 결과
테스트 케이스 1: 실패 (입력: 5, apple banana orange grape pineapple, apple, 기대값: "있습니다", 결과: 있습니다)
테스트 케이스 2: 실패 (입력: 5, apple banana orange grape pineapple, mango, 기대값: "없습니다", 결과: 없습니다)
테스트 케이스 3: 실패 (입력: 3, trie tree structure, trie, 기대값: "있습니다", 결과: 있습니다)
테스트 케이스 4: 실패 (입력: 3, trie tree structure, tea, 기대값: "없습니다", 결과: 없습니다)
테스트 케이스 5: 실패 (입력: 6, i like cpp programming problem, programming, 기대값: "있습니다", 결과: 없습니다)
테스트 케이스 6: 실패 (입력: 6, i like cpp programming problem, java, 기대값: "없습니다", 결과: 없습니다)
테스트 케이스 7: 실패 (입력: 2, hello world, world, 기대값: "있습니다", 결과: 있습니다)
테스트 케이스 8: 실패 (입력: 2, hello world, world!, 기대값: "없습니다", 결과: 없습니다)
테스트 케이스 9: 실패 (입력: 10, abc def ghi jkl mno pqr stu vwx yza bcd, yza, 기대값: "있습니다", 결과: 있습니다)
테스트 케이스 10: 실패 (입력: 10, abc def ghi jkl mno pqr stu vwx yza bcd, opq, 기대값: "없습니다", 결과: 없습니다)
0/10 테스트 케이스 통과

---

